---
layout: post
title:  "[BoB 프로젝트 주제 분석]"
date:   2025-10-16
categories: "기술문서/블로그"
tags: image
image: /assets/article_images/2025-10-16-can/pink.png
---


# CAN 네트워크를 통한 자동차 제어

## CAN (Controller Area Network)

- 차량 내 각 ECU 장치들이 Host Computer 없이 서로 통신하기 위해 설계된 Message 기반 표준 Protocol
- ECU(Electronic Control Unit): 자동차 내에서 엔진, 변속기, 브레이크 등을 제어하는 임베디드 시스템
- 차량의 원활한 제어를 위해 각 ECU 간의 통신이 필요

### 취약점

- 주소 개념이 없음
    - CAN은 출발지/목적지 주소가 없고, 단순히 메시지 ID만으로 구분  
    → 누가 보냈는지는 알 수 없음: 공격자가 같은 ID로 위조 메시지를 보내는 게 가능
- 보안 기능이 없음
    - 암호화 x
    - 인증 x
    - 무결성 검증 x

## Network topology

**초기: MESH**  
partially connected

![image.png](/assets/article_images/2025-10-16-can/image.png)

복잡한 인터페이스, 정비 어려움, 무게/비용 증가, 확장 어려움

**현재 : bus**  
![image.png](/assets/article_images/2025-10-16-can/image%201.png)

단순한 하네스 구조, 정비 쉬움, 비용 감소, 가벼움, 용이한 확장성

## Characteristics

<ol markdown="1">
  <li>
    <p><strong>Multi-master access / Broadcast</strong></p>
    <p>모든 ECU는 메시지를 송신할 수 있고, 모든 ECU는 그 메시지를 수신할 수 있음</p>
    
    <img src="/assets/article_images/2025-10-16-can/image%202.png" alt="image.png">
  </li>
  <li>
    <p><strong>CSMA/CD (Carrier Sense Multiple Access with Collision Detection)</strong></p>
    <ul>
      <li>여러 장치가 하나의 공유된 통신 채널을 사용할 때 충돌을 피하기 위한 방법</li>
      <li>충돌 발생 시 전송을 멈춤</li>
    </ul>
    
    <img src="/assets/article_images/2025-10-16-can/image%203.png" alt="image.png">
  </li>
  <li>
    <p><strong>Message prioritization</strong></p>
    <ul>
      <li>여러 노드가 동시에 전송을 시도할 때, 버스 상에서 충돌 없이 우선순위가 높은 메시지만 살아남는 방식</li>
      <li>Arbitration Field(식별자 + 제어 비트)를 비교</li>
      <li>Dominant(우성) bit: 0 (>= 0.9 V), Recessive(열성) bit: 1 (<= 0.5 V)</li>
    </ul>
    
    <img src="/assets/article_images/2025-10-16-can/image%204.png" alt="image.png">

    <p><strong>2.0A vs 2.0B</strong></p>
    
    <img src="/assets/article_images/2025-10-16-can/image%205.png" alt="image.png">
    
    <img src="/assets/article_images/2025-10-16-can/image%206.png" alt="image.png">
    
    Arbitration Field와 Control Field가 달라짐

    <table class="md-table">
      <thead>
        <tr>
          <th>구분</th>
          <th>CAN 2.0A</th>
          <th>CAN 2.0B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Identifier 길이</td>
          <td>11비트</td>
          <td>29비트</td>
        </tr>
        <tr>
          <td>Arbitration Field</td>
          <td>ID(11) + RTR(1)</td>
          <td>ID(11) + SRR(1) + IDE(1) + Ext ID(18) + RTR(1)</td>
        </tr>
        <tr>
          <td>IDE 비트</td>
          <td>0 (Standard)</td>
          <td>1 (Extended)</td>
        </tr>
        <tr>
          <td>메시지 ID 개수</td>
          <td>2,048개</td>
          <td>약 5억 개</td>
        </tr>
        <tr>
          <td>호환성</td>
          <td>2.0A끼리만 완전 호환</td>
          <td>2.0A/2.0B 모두 수신 가능</td>
        </tr>
      </tbody>
    </table>

    <p><strong>같은 11비트 Base ID를 가진 2.0A 프레임과 2.0B 프레임이 동시에 전송된다면:</strong></p>
    <ol>
      <li><strong>CAN 2.0A Remote Frame</strong>
        <ul>
          <li>Arbitration Field = 11비트 ID + RTR(1비트, 0일 수도 있고 1일 수도 있음)</li>
          <li>Control Field = 1 비트 IDE(항상 0) + 1 bit reservation + 4 bits</li>
        </ul>
      </li>
      <li><strong>CAN 2.0B Extended Frame</strong>
        <ul>
          <li>Arbitration Field = 11비트 Base ID + SRR(항상 1, recessive) + IDE(항상 1, recessive) + 18비트 Extended ID + RTR</li>
        </ul>
      </li>
    </ol>
    <p>→ 2.0A의 RTR이 1이더라도 13번째 비트가 2.0A는 0, 2.0B는 1이므로 A가 우선</p>
    <br>
    <p><strong>문제 예시</strong></p>
    
    <img src="/assets/article_images/2025-10-16-can/image%207.png" alt="image.png">

    식별자(ID)가 낮을수록 우선순위가 높음  
    0x123 < 0x140  
    → 0x123가 더 낮은 값이므로 먼저 전송됨  
    참고: 데이터 필드(EF EF EF EF, 00 00 00 00)는 우선순위 결정에 영향 x
  </li>
  <li>
    <p><strong>Limited data length (0-8 bytes)</strong></p>
    <p>DLC (Data Length Code) : 데이터 필드에 포함된 데이터 바이트의 수<br>
    DLC == 데이터 필드 바이트의 길이</p>
   
   <img src="/assets/article_images/2025-10-16-can/image%208.png" alt="image.png">
  </li>
  <li>
    <p><strong>Up to 1 Mbit/s data rate</strong></p>
    <p>차량의 실시간 제어와 안정적인 데이터 교환을 가능하게 함</p>

    | 유형 | 속도 범위 | 설명 |
    | --- | --- | --- |
    | CAN-A | ~10 kbit/s | 저속, 간단한 센서용 |
    | CAN-B | 10~125 kbit/s | 중속, 일반 제어용 |
    | CAN-C | 125~1000 kbit/s | 고속, 실시간 제어용 (최대 1 Mbit/s) |
  </li>
</ol>

## Frame

### Data frame

![image.png](/assets/article_images/2025-10-16-can/image%209.png)

| 필드 | 크기 | 설명 |
| --- | --- | --- |
| **Start of Frame (SOF)** | 1 bit | 프레임 시작을 알림 (동기화용) |
| **Arbitration Field** | 11비트(2.0A) 또는 29비트(2.0B) | 메시지 ID와 우선순위 결정, RTR 비트 포함 |
| **Control Field** | 6 bits | IDE(확장 여부), 예약 비트, DLC(Data Length Code: 데이터 길이) |
| **Data Field** | 0~64 bits (0~8 bytes) | 실제 전송되는 데이터 |
| **CRC Field** | 16 bits | 오류 검출을 위한 Cyclic Redundancy Check |
| **ACK Field** | 2 bits | 수신 노드가 정상 수신 여부를 확인 (송신 노드가 아닌 수신 노드가 설정) |
| **End of Frame (EOF)** | 7 bits | 프레임 종료 표시 |
| **Interframe Space (IFS)** | 3 bits | 프레임 간 간격 (111) |

<br>
**특징**

1. 각 프레임이 끝난 뒤 3비트(111)의 간격이 들어감
2. RTR(Remote Transmission Request): 0 → remote frame과 구별하기 위함
3. Transmitter node ↔ Receiver node

### Remote frame

![image.png](/assets/article_images/2025-10-16-can/image%2010.png)

**특징**

1. RTR: 1  
→ remote frame과 data frame이 충돌할 경우 Identifier의 11bit가 동일하다면 data frame의 RTR이 0이기 때문에 항상 우선권을 가짐 
2. Transmitter node -> Receiver node (request message)

### Error frame

![image.png](/assets/article_images/2025-10-16-can/image%2011.png)

- Error Flag (6비트)
    - 오류를 알리는 신호
    - Active Error Flag: 000000
    - Passive Error Flag: 111111
- Echo Error Flag
    - Error Flag가 전송된 뒤, 버스 전파 지연(delay) 때문에 다른 ECU들이 뒤늦게 오류를 감지하고 추가로 Error Flag를 내보낼 수 있음
    - 이때 기존 Error Flag에 이어 붙는 형태로 나타나는 것이 Echo Error Flag
    - 결과적으로 Error Flag + Echo Error Flag로 이어져서, 오류 신호가 네트워크 전체에 확실히 퍼지도록 보장
- Error Delimiter (8비트)
    - 11111111 (recessive)
    - error 프레임의 끝을 표시
- Error frame은 Data/Remote frame뒤에 바로 붙어 전송됨(IFS x)

### 에러 종류

<ol>
  <li>
    <p><strong>bit error</strong><br>
    노드가 버스에 보낸 비트와 버스에서 실제로 관측한 비트가 다른 경우 발생</p>
    <img src="/assets/article_images/2025-10-16-can/image%2012.png" alt="image.png">
    <ul>
      <li>여기서 node2가 receiver로 단순히 bus에 올라온 값을 읽음</li>
      <li>네번째 막대에서 node1 값은 0인데 bus에는 1이 올라감(0이 dominant한데도)</li>
      <li>node1이 자기 값이랑 bus값을 비교해서 에러 감지, 즉시 active error flag를 내보내며 프레임을 무효화하고 이후에 재전송함</li>
    </ul>
  </li>
  <li>
    <p><strong>stuff error</strong><br>
    CAN의 비트 스터핑 규칙(연속 동일 비트 5개 후 반대 비트 삽입, 수신 CAN 노드에서 자동으로 제거됨) 위반 시 발생</p>
    <img src="/assets/article_images/2025-10-16-can/image%2013.png" alt="image.png">
    <img src="/assets/article_images/2025-10-16-can/image%2014.png" alt="image.png">
    <p>붉은색으로 표시된 부분에 스터핑 규칙 적용, error/overload frame에는 적용 x</p>
  </li>
  <li>
    <p><strong>CRC error</strong><br>
    수신 노드가 계산한 CRC와 프레임 내 CRC 필드 값이 다름</p>
    <img src="/assets/article_images/2025-10-16-can/image%2015.png" alt="image.png">
    <ul>
      <li><strong>Node 1 (송신자)</strong>
        <ul>
          <li>데이터 프레임을 전송하면서 마지막에 CRC 시퀀스(X)를 붙여서 보냄</li>
          <li>이 CRC는 송신자가 자기 데이터(ID, DLC, Data Field 등)를 기반으로 계산한 값</li>
        </ul>
      </li>
      <li><strong>Bus (공유 매체)</strong>
        <ul>
          <li>송신자가 보낸 CRC 값(X)이 그대로 버스에 올라감</li>
        </ul>
      </li>
      <li><strong>Node 2 (수신자)</strong>
        <ul>
          <li>Node 2는 수신한 데이터(ID, DLC, Data Field 등)를 기반으로 자체적으로 CRC를 다시 계산</li>
          <li>계산 결과가 Y였는데, 버스에서 받은 CRC 값(X)와 다르면 → CRC Error</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Form error</strong><br>
    특정 포맷 필드가 표준 규격과 다른 값을 가질 때 발생</p>
    <img src="/assets/article_images/2025-10-16-can/image%2016.png" alt="image.png">
    <p>SOF, CRC Del, ACK Del, EOF 의 값이 1이어야 하는데 0으로 관측되는 등</p>
  </li>
  <li>
    <p><strong>ACK error</strong><br>
    송신 노드가 ACK 슬롯에서 0을 읽지 못했을 때(응답 노드가 없거나 모두 실패)</p>
    <img src="/assets/article_images/2025-10-16-can/image%2017.png" alt="image.png">
    <ul>
      <li>ACK Slot (1비트)
        <ul>
          <li>송신 노드는 항상 recessive(1)을 내보냄</li>
          <li>수신 노드가 프레임을 정상적으로 받았다면, 이 자리에서 dominant(0)를 내보냄</li>
        </ul>
      </li>
      <li>ACK Delimiter (1비트)
        <ul>
          <li>항상 recessive(1)</li>
        </ul>
      </li>
    </ul>
    <p>송신 노드가 ACK Slot에서 recessive(1)만 읽은 경우 → 즉, 어느 수신 노드도 dominant(0)으로 응답하지 않은 경우 에러</p>
  </li>
  <li>
    <p><strong>Appllication error</strong></p>
    <ul>
      <li>상위 소프트웨어/로직 오류 (의미적 데이터 문제)</li>
      <li>CAN 프로토콜 레벨에서는 Error Frame이 발생하지 않을 수도 있음</li>
      <li>대신 ECU가 메시지를 무시하거나 Fault 상태로 전환, DTC 기록 등으로 처리</li>
    </ul>
  </li>
</ol>
    

### Overload frame

![image.png](/assets/article_images/2025-10-16-can/image%2018.png)

- 수신 노드가 내부적으로 바빠서 다음 메시지를 바로 처리할 수 없거나(지연 요구) IFS 구간에서 dominant 비트가 감지되면 Overload Frame으로 인식
- Overload Flag (6비트)
    - 000000 (dominant)
    - Error Flag와 동일한 패턴이지만, IFS 구간에서만 나오면 Overload Frame으로 해석
- Overload Delimiter (8비트)
    - 11111111 (recessive)
    - Overload Frame의 끝을 표시
- overload frame은 Data/Remote frame뒤에 바로 붙어 전송됨(IFS x)

# Attack Scenarios

### DoS (Denial of Service, Flooding)

높은 우선순위의 CAN ID  또는 데이터 필드를 주입하면 CAN 버스의 가용성이 파괴됨

### Spoofing

공격자의 의도에 따라 하나 이상의 타겟 ECU를 제어함  
구체적인 데이터 필드로 CAN 메시지를 주입

![image.png](/assets/article_images/2025-10-16-can/image%2019.png)

### Replay

정상 주행 중 데이터를 수집해 공격자가 원하는 시점에 이 메시지들을 전송

![image.png](/assets/article_images/2025-10-16-can/image%2020.png)

### Fuzzing

랜덤한 CAN ID와 데이터 필드를 보냄(공격자도 알 수 x)

![image.png](/assets/article_images/2025-10-16-can/image%2021.png)

### Bus-off(Suspension attack)

정상적으로 동작하는 ECU를 CAN bus에서 제거하기 위한 공격  
error frame이 발생하면 ECU는 해당 CAN 메시지를 재전송하므로 CAN bus의 부하가 증가함  
→ 이를 해결하기 위해 passive/active/bus-off 모드가 구현되어 있음

- Error active 모드: 기본 상태, error frames가 128개 미만일 때
- Error passive 모드: 데이터를 보내기 위해선 IFS (3비트) 이후 8비트를 더 기다림
- Bus-off: 더 이상 데이터를 전송할 수 없음, ECU 재부팅 후에 데이터 전송 가능

![image.png](/assets/article_images/2025-10-16-can/image%2022.png)

### Masquerade attack(Bus-off + Spoofing/Replay)

- Spoofing 공격에서 정상적으로 작동하는 CAN ID의 데이터도 표시가 됨
- 실제 차량이 정상 데이터와 공격 데이터를 번갈아 수신받기 때문에 공격의 피해가 줄어듦
- 탐지도 쉬워지기 때문에 공격자는 정상적으로 작동하는 ECU를 제거한 뒤 메시지를 보냄




실제 차량에 적용된 여러 보호기법을 공부하고 이를 우회해 공격하는 방법을 추가적으로 공부해보고 싶다. 

참고자료: [HCRL](https://ocslab.hksecurity.net/publications) 이휘재
