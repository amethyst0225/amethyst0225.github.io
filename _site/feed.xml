<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Youngin Won</title>
    <description>wonyoungin04@gmail.com
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 16 Oct 2025 23:15:01 +0900</pubDate>
    <lastBuildDate>Thu, 16 Oct 2025 23:15:01 +0900</lastBuildDate>
    <generator>Jekyll v3.10.0</generator>
    
      <item>
        <title>[BoB 프로젝트 주제 분석]</title>
        <description>&lt;h1 id=&quot;solidity-기반-스마트-컨트랙트-취약점-분석-및-점검-툴-개발&quot;&gt;Solidity 기반 스마트 컨트랙트 취약점 분석 및 점검 툴 개발&lt;/h1&gt;

&lt;h2 id=&quot;스마트-컨트랙트&quot;&gt;스마트 컨트랙트&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;블록체인 플랫폼에서 실행되는 자동화된 계약 프로그램&lt;/li&gt;
  &lt;li&gt;Solidity로 작성된 스마트 컨트랙트는 배포 후 수정이 어렵고, 한 번의 실수가 막대한 자산 손실로 이어질 수 있음&lt;/li&gt;
  &lt;li&gt;컨트랙트 배포 전 단계에서 재진입(Reentrancy), 접근제어 오류, 산술/가스 한도, 업그레이어블 패턴 위험 등을 조기에 탐지·차단하는 방법에 대한 연구가 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주제-선정-이유&quot;&gt;주제 선정 이유&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;탈중앙화 금융(DeFi), NFT, DAO 등 블록체인 기반 서비스가 확산되면서 스마트 컨트랙트의 사용 급증 → 이에 따라 보안 검증의 필요성도 함께 증가하고 있음&lt;/li&gt;
  &lt;li&gt;스마트 컨트랙트의 오류는 시간이 지남에 따라 반복적으로 발생하며 금전적 손실을 발생시킴. 보안 도구 개발이 이러한 피해를 사전에 예방할 수 있는 실질적인 해결책&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주요-스마트-컨트랙트-취약점-유형&quot;&gt;주요 스마트 컨트랙트 취약점 유형&lt;/h2&gt;

&lt;h3 id=&quot;1-reentrancy-attack-재진입-공격&quot;&gt;(1) &lt;a href=&quot;https://blog.chain.link/reentrancy-attacks-and-the-dao-hack/&quot;&gt;Reentrancy Attack&lt;/a&gt; (재진입 공격)&lt;/h3&gt;

&lt;p&gt;재진입 공격은 외부 계약이 원래 함수로 다시 호출되어 코드 실행을 임의의 위치에서 재진입하는 방식으로 작동&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공격 메커니즘&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 취약한 코드 예시
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 외부 호출이 먼저 발생
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 상태 변경이 나중에 발생
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;외부 계약의 출금 함수를 호출하기 직전에 userBalances의 상태를 업데이트함으로써 방지할 수 있음&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;방어 기법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Checks-Effects-Interactions 패턴&lt;/li&gt;
  &lt;li&gt;ReentrancyGuard 모디파이어 사용&lt;/li&gt;
  &lt;li&gt;Mutex 패턴&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-integer-overflowunderflow&quot;&gt;(2) Integer Overflow/Underflow&lt;/h3&gt;

&lt;p&gt;데이터 타입 범위를 초과하는 숫자를 추가할 때 발생&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;방어 기법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SafeMath 라이브러리 사용 (0.8.0 이전 버전)&lt;/li&gt;
  &lt;li&gt;Solidity 0.8.0 이상 사용 (자동 체크)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-unchecked-external-calls&quot;&gt;(3) &lt;a href=&quot;https://www.cobalt.io/blog/smart-contract-security-risks&quot;&gt;Unchecked External Calls&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;스마트 컨트랙트가 외부 함수 호출의 결과를 검증하지 않을 때 발생하는 취약점&lt;/li&gt;
  &lt;li&gt;호출이 실패해도 예외 오류를 발생시키지 않아 계약이 성공한 것처럼 진행될 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;방어 기법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transfer()&lt;/code&gt; 사용 (실패 시 자동 revert)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send()&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call()&lt;/code&gt;의 반환값 체크&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-access-control-문제&quot;&gt;(4) &lt;a href=&quot;https://hacken.io/discover/most-common-smart-contract-vulnerabilities/&quot;&gt;Access Control 문제&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Solidity의 함수는 가시성 지정자를 가지며, 이는 함수가 어떻게 호출될 수 있는지를 결정함&lt;/li&gt;
  &lt;li&gt;함수의 기본 가시성은 public이므로, 가시성을 지정하지 않은 함수는 외부 사용자가 호출할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;방어 기법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;명시적으로 함수 가시성 지정&lt;/li&gt;
  &lt;li&gt;적절한 접근 제어 메커니즘 구현&lt;/li&gt;
  &lt;li&gt;다중 서명 지갑 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대표적인-해킹-사례-the-dao-attack-2016&quot;&gt;대표적인 해킹 사례: &lt;a href=&quot;https://coinmarketcap.com/academy/article/a-history-of-the-dao-hack&quot;&gt;The DAO Attack (2016)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The DAO는 2016년 이더리움 블록체인에서 시작된 탈중앙화 자율 조직으로, 토큰 세일을 통해 1억 5천만 달러 상당의 이더를 모금한 후 코드베이스의 취약점으로 인해 해킹당함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공격 과정&lt;/strong&gt;&lt;br /&gt;
초당 100 ETH의 속도로 The DAO 스마트 컨트랙트에서 이더를 유출시킴&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;대응&lt;/strong&gt;&lt;br /&gt;
하드 포크: The DAO 공격 이전으로 이더리움 네트워크의 히스토리를 되돌려 The DAO의 이더를 다른 스마트 컨트랙트로 재할당하여 투자자들이 자금을 인출할 수 있도록 함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;결과&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이더리움이 두 개의 체인으로 분할: Ethereum (ETH)과 Ethereum Classic (ETC)&lt;/li&gt;
  &lt;li&gt;스마트 컨트랙트 보안의 중요성 부각&lt;/li&gt;
  &lt;li&gt;감사(Audit) 문화 확립&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;최신-취약점-분석-도구&quot;&gt;최신 취약점 분석 도구&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-정적-분석-도구&quot;&gt;(1) 정적 분석 도구&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cyfrin.io/blog/industry-leading-smart-contract-auditing-and-security-tools&quot;&gt;&lt;strong&gt;Slither&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Python 기반&lt;/li&gt;
  &lt;li&gt;Solidity 코드에 대한 광범위한 취약점 탐지기를 제공&lt;/li&gt;
  &lt;li&gt;빠른 실행 시간, 낮은 오탐률, CI 파이프라인 통합 능력&lt;/li&gt;
  &lt;li&gt;장점: 92개 이상의 취약점 탐지기, Python API를 통한 커스텀 분석&lt;/li&gt;
  &lt;li&gt;지원: Hardhat, Foundry, DappTools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quillaudits.com/blog/smart-contract/smart-contract-security-tools-guide&quot;&gt;&lt;strong&gt;Aderyn&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Rust 기반&lt;/li&gt;
  &lt;li&gt;Solidity 스마트 컨트랙트의 취약점을 탐지&lt;/li&gt;
  &lt;li&gt;AST를 순회하여 잠재적 문제를 마크다운 형식으로 보고&lt;/li&gt;
  &lt;li&gt;장점: 빠른 탐지, 낮은 오탐, CI/CD 통합, Nyth를 통한 커스텀 분석 프레임워크&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.rapidinnovation.io/post/top-7-smart-contract-audit-tools&quot;&gt;&lt;strong&gt;Mythril&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Python 기반 스마트 컨트랙트 감사 도구&lt;/li&gt;
  &lt;li&gt;오염 분석 및 심볼릭 실행과 같은 고급 분석 기법을 제공&lt;/li&gt;
  &lt;li&gt;EVM 바이트코드만으로도 분석이 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-퍼징-도구&quot;&gt;(2) 퍼징 도구&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quillaudits.com/blog/smart-contract/smart-contract-security-tools-guide&quot;&gt;&lt;strong&gt;Echidna&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이더리움 스마트 컨트랙트를 위한 속성 기반 퍼징 도구&lt;/li&gt;
  &lt;li&gt;사용자 정의 속성에 대해 계약을 테스트하여 취약점을 식별&lt;/li&gt;
  &lt;li&gt;특징: 속성 기반 퍼징, 사용자 정의 assertion, 커버리지 리포팅&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cyfrin.io/blog/industry-leading-smart-contract-auditing-and-security-tools&quot;&gt;&lt;strong&gt;Medusa&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Echidna에서 영감을 받은 실험적 스마트 컨트랙트 퍼저&lt;/li&gt;
  &lt;li&gt;CLI 또는 Go API를 통한 병렬 퍼즈 테스트를 가능하게 함&lt;/li&gt;
  &lt;li&gt;특징: 멀티스레드 병렬 퍼징, Solidity 속성 및 assertion 테스트, 커버리지 기반 퍼징&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cyfrin.io/blog/industry-leading-smart-contract-auditing-and-security-tools&quot;&gt;&lt;strong&gt;Diligence Fuzzing&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Harvey로 구동되는 완전한 스마트 컨트랙트 퍼징 서비스 플랫폼&lt;/li&gt;
  &lt;li&gt;Harvey는 이더리움 바이트코드를 위한 강력한 퍼저&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-형식-검증-도구&quot;&gt;(3) 형식 검증 도구&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quillaudits.com/blog/smart-contract/smart-contract-security-tools-guide&quot;&gt;&lt;strong&gt;Halmos&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이더리움 스마트 컨트랙트를 위한 오픈소스 형식 검증 도구&lt;/li&gt;
  &lt;li&gt;계약 로직을 분석하기 위해 제한된 심볼릭 실행을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-ai-기반-도구&quot;&gt;(4) AI 기반 도구&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quillaudits.com/blog/smart-contract/smart-contract-security-tools-guide&quot;&gt;&lt;strong&gt;QuillShield&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;일반적인 취약점을 넘어 논리적 오류를 탐지하여 스마트 컨트랙트 감사를 향상시킴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.nature.com/articles/s41598-023-47219-0&quot;&gt;&lt;strong&gt;Lightning Cat&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;딥러닝 기법을 기반으로 한 솔루션&lt;/li&gt;
  &lt;li&gt;CodeBERT 모델을 최적화하고 CNN과 결합하여 취약점 코드에서 중요한 특징을 추출하고 강력한 의미 분석 능력을 갖춤&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-통합-플랫폼&quot;&gt;(5) 통합 플랫폼&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cyfrin.io/blog/industry-leading-smart-contract-auditing-and-security-tools&quot;&gt;&lt;strong&gt;Solodit&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;여러 보안 회사와 최고 연구자들의 15,000개 이상의 보안 취약점 및 버그 바운티를 집계&lt;/li&gt;
  &lt;li&gt;기능: 8,000개 이상의 취약점 데이터베이스, 버그 바운티 추적, 감사 체크리스트&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 16 Oct 2025 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C/%EB%B8%94%EB%A1%9C%EA%B7%B8/2025/10/16/smart_contract.html</link>
        <guid isPermaLink="true">http://localhost:4000/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C/%EB%B8%94%EB%A1%9C%EA%B7%B8/2025/10/16/smart_contract.html</guid>
        
        <category>image</category>
        
        
        <category>기술문서/블로그</category>
        
      </item>
    
      <item>
        <title>[BoB 프로젝트 주제 분석]</title>
        <description>&lt;h1 id=&quot;bug-hunting-guide-line--secure-coding&quot;&gt;bug hunting guide line &amp;amp; secure coding&lt;/h1&gt;

&lt;h2 id=&quot;1-개념&quot;&gt;1. 개념&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Bug hunting: 소프트웨어 또는 하드웨어의 오류(버그)를 찾아내서 제보하는 행위. 단순 취약점 찾기 뿐 아니라 체계적 접근과 결과 입증(재현성) 및 영향평가가 중요하며, MS SDL 등 위협모델링 기반 접근이 필수로 자리잡음.&lt;/li&gt;
  &lt;li&gt;Secure coding: 설계, 구현 전 과정에서 보안을 내재화(Security by Design)해야 하며, 처음부터 위협모델링–보안요구 분석–코드 리뷰–테스트–배포 전 게이트 등 전체 주기를 구조화해야 효과적.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-bug-hunting-guideline&quot;&gt;2. Bug Hunting Guideline&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;핵심-요소&quot;&gt;핵심 요소&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; 범위 정의&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;테스트 대상 시스템/기능 명확히 하기&lt;/li&gt;
  &lt;li&gt;허용되는 테스트 방법과 금지 사항 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 체계적 접근법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;재현 가능한 버그 찾기&lt;/li&gt;
  &lt;li&gt;명확한 재현 단계 문서화&lt;/li&gt;
  &lt;li&gt;버그의 영향도 평가 (심각도, 우선순위)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 보고 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;버그 제목과 설명을 명확하게 작성&lt;/li&gt;
  &lt;li&gt;재현 단계를 순서대로 기록&lt;/li&gt;
  &lt;li&gt;스크린샷, 로그 등 증거 첨부&lt;/li&gt;
  &lt;li&gt;예상 결과 vs 실제 결과 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 윤리적 원칙&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;허가된 범위 내에서만 테스트&lt;/li&gt;
  &lt;li&gt;발견한 취약점 악용 금지&lt;/li&gt;
  &lt;li&gt;책임있는 공개(Responsible Disclosure)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-secure-coding-핵심-원칙&quot;&gt;3. Secure Coding 핵심 원칙&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;최소 권한(Least privilege): 코드, 프로세스, 사용자 등 모든 엔티티는 반드시 필요한 권한만 부여&lt;/li&gt;
  &lt;li&gt;실패-안전 기본값(Fail-safe defaults): 기본 거부 및 명시적 허용, 오류·예외 시 안전모드로 수렴&lt;/li&gt;
  &lt;li&gt;완전 매개/중재(Complete mediation): 모든 접근 마다 권한 검증(캐시된 결정은 권한변경 때 무효화)&lt;/li&gt;
  &lt;li&gt;경제성(Economy of mechanism): 단순 구조, 작은 크기 → 검증·분석·운영이 쉬움&lt;/li&gt;
  &lt;li&gt;개방 설계(Open design): 설계는 공개/검증 가능해야 하며, 비밀 유지의 중점은 키에(‘security through obscurity’는 지양)&lt;/li&gt;
  &lt;li&gt;권한 분리(Separation of privilege): 두 개 이상의 조건(예: 2인 승인) 필요 상황에선 반드시 다중 인증(2FA 등) 사용&lt;/li&gt;
  &lt;li&gt;공유 최소화(Least common mechanism): 여러 사용자/서브시스템이 공유하는 메커니즘은 최소화, 교차영향·사이드채널 차단&lt;/li&gt;
  &lt;li&gt;심리적 수용성(Psychological acceptability): 개발자/사용자 관점 모두에서 이해·사용 쉬운 보안 인터페이스 필요&lt;/li&gt;
  &lt;li&gt;방어 심층화(Defense in depth): 단일 취약점으로 전체 뚫리는 것을 방지하는 다층 구조 적용&lt;/li&gt;
  &lt;li&gt;효과적 로깅(Effective logging): 접근/행동 추적, 위변조 방지, 개인정보·비밀키 등 민감정보 미기록&lt;/li&gt;
  &lt;li&gt;Build-in, Not bolt-on: 보안을 사후(‘패치’)가 아니라 애초에 설계에 반영해야 함&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-프로세스-built-in-security&quot;&gt;4. 프로세스: Built-in Security&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;요구사항/분석: ‘무엇이 안전한가?’의 정의, 위험 기반 요구사항 추출(STRIDE, LINDDUN 등 모델 활용)&lt;/li&gt;
  &lt;li&gt;설계단계: 위협모델링, DFD/UML 등 다이어그램화 → 공격자 시나리오·파급효과 분석, 방어 수단 내재화&lt;/li&gt;
  &lt;li&gt;구현/코딩: 안전한 프레임워크, 라이브러리 사용 및 리뷰, 정적분석 도구, Secure-by-default 옵션 유지&lt;/li&gt;
  &lt;li&gt;시험/검증: 동적분석 및 펜테스트 등으로 설계·코드상의 취약점 검증(OWASP Top 10, SANS 등 참고)&lt;/li&gt;
  &lt;li&gt;배포/운영: 배포 전 보안게이트(코드 리뷰, 분석, 위협모델 검증 등), 자동화/CI 연계 기준 마련&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-security-theater&quot;&gt;5. Security Theater&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;보안 효과 없는 정책·도구 남용 금지: 망분리·다중 보안툴 등 ‘느낌만’ 주는 보안에 그쳐 실제 위협 감소 효능 x&lt;/li&gt;
  &lt;li&gt;운영 복잡성 증가·공격면 확장·사용자 불편에 상응하는 실증적 효과가 없을 경우 정책 재점검 필요&lt;/li&gt;
  &lt;li&gt;실사례: 평문 자격증명·민감정보, 로그 부재 등 실제 유출 대응·탐지 불능이 반복됨. 저장중 암호화, 키 분리관리, 로그 위변조 방지 등을 지켜야 진짜 보안&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-실제-시스템-적용-관점ssdlc&quot;&gt;6. 실제 시스템 적용 관점(SSDLC)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-secure_coding/image.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인증·세션: STS 등 표준 프로토콜, 상호 인증/키합의 연계, 토큰 만료 짧게·회전/폐기 가능 구조&lt;/li&gt;
  &lt;li&gt;입력 검증: 경로·쿼리·헤더·파일명 등은 화이트리스트+정규식+컨텍스트 인코딩으로 단일 파서화&lt;/li&gt;
  &lt;li&gt;데이터 보호: 저장·전송 전체 강한 암호화, 키는 HSM 등 외부 금고에 격리 저장. 하드코딩 키/비밀정보는 금지&lt;/li&gt;
  &lt;li&gt;권한·리소스 경계: 객체별 권한검사 강제, 각 기능/객체별 최소권한화, 임시 자격증명·세션엔 만료·범위 체크&lt;/li&gt;
  &lt;li&gt;에러/로깅: 사용자 에러는 민감정보 노출 없이, 내부 로그만 위변조 방지/보존주기 설정&lt;/li&gt;
  &lt;li&gt;서드파티/의존성: 안전한 기본설정 유지, 의존성 취약점 탐지 자동화, 수시 SLO·업데이트 운용&lt;/li&gt;
  &lt;li&gt;배포 전 게이트: 모든 주요 보안점검(정적/동적/조합 분석, 위협모델, 코드리뷰 등) 통과 후에만 배포&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-threat-modeling&quot;&gt;7. Threat Modeling&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;threat-modeling-단계&quot;&gt;&lt;strong&gt;Threat Modeling 단계&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1. DFD 작성 및 시스템 범위‧Trust Boundary 확정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFD(Data Flow Diagram)로 시스템의 데이터 흐름, 외부 엔터티, 내부 프로세스, 데이터 저장소, Trust Boundary(신뢰 경계; 권한·신뢰 수준이 바뀌는 지점)를 시각적으로 표현&lt;/li&gt;
  &lt;li&gt;Trust Boundary 주위에서 권한 상승(EoP)·우회(Tampering) 등 위험이 주로 발생하며, exploit 코딩의 주요 진입점이 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-secure_coding/image%201.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 자산(Asset) 파악&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보호해야 할 핵심 자산(데이터, 서비스, 인증정보 등) 식별, 공격 성공 시 위험이 큰 타깃 위주로 모델링&lt;/li&gt;
  &lt;li&gt;실제 exploit 구현의 목표가 되는 지점과 일치.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 위협 및 취약점 식별(STRIDE, LINDDUN 등 활용)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;STRIDE: Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-secure_coding/image%202.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LINDDUN: 개인정보 위험 평가에 최적화됨&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-secure_coding/image%203.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 Threat별로 공격 시나리오/공격트리(Attack Tree)로 구체화 → exploit 개발시 시나리오 뼈대 역할을 함&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-secure_coding/image%204.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4. 위험 우선순위 산정(DREAD, TARA, Simple/Qualitative Risk Model 적용)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DREAD: Damage/Reproducibility/Exploitability/Affected users/Discoverability&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-secure_coding/image%205.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공격 난이도, 피해 규모 등 계량화→익스플로잇 타겟 선정 결정적 근거&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5. 대응방안 도출(Reduce, Transfer, Accept, Avoid) 및 반복 갱신&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Countermeasure 설계: Exploit 성공을 막기 위한 방어책(완화)&lt;/li&gt;
  &lt;li&gt;exploitable bug 발견 → exploit 개발/공격자 관점에서 최종 우회 코드(서로 피드백/루프 구조)로 연결&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
주요 기업들이 실제로 보안을 어떻게 체계적으로 구축·유지하는지 파악하고자 이번 주제를 조사하게 되었다. 조사 과정에서 단순히 보안 정책만 도입하기보다는 Threat Modeling과 같은 사전 위험 식별 과정과 개발 과정에서의 보안 내재화가 핵심임을 알게 되었다. 실제로 많은 기업들이 Security by Design원칙 하에 요구사항 단계부터 배포까지 보안을 기본 공정으로 포함하고 있다.&lt;/p&gt;

&lt;p&gt;추후에는 간단한 예시 상황에 직접 Threat Modeling 절차를 단계적으로 적용해보고, 도출된 위협 시나리오에 어떤 방식으로 Secure Coding 원칙들을 실제 소스 코드에 반영할 수 있을지 실습해보고 싶다.&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Oct 2025 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C/%EB%B8%94%EB%A1%9C%EA%B7%B8/2025/10/16/secure_coding.html</link>
        <guid isPermaLink="true">http://localhost:4000/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C/%EB%B8%94%EB%A1%9C%EA%B7%B8/2025/10/16/secure_coding.html</guid>
        
        <category>image</category>
        
        
        <category>기술문서/블로그</category>
        
      </item>
    
      <item>
        <title>[BoB 프로젝트 주제 분석]</title>
        <description>&lt;h1 id=&quot;can-네트워크를-통한-자동차-제어&quot;&gt;CAN 네트워크를 통한 자동차 제어&lt;/h1&gt;

&lt;h2 id=&quot;can-controller-area-network&quot;&gt;CAN (Controller Area Network)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;차량 내 각 ECU 장치들이 Host Computer 없이 서로 통신하기 위해 설계된 Message 기반 표준 Protocol&lt;/li&gt;
  &lt;li&gt;ECU(Electronic Control Unit): 자동차 내에서 엔진, 변속기, 브레이크 등을 제어하는 임베디드 시스템&lt;/li&gt;
  &lt;li&gt;차량의 원활한 제어를 위해 각 ECU 간의 통신이 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;취약점&quot;&gt;취약점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;주소 개념이 없음
    &lt;ul&gt;
      &lt;li&gt;CAN은 출발지/목적지 주소가 없고, 단순히 메시지 ID만으로 구분&lt;br /&gt;
  → 누가 보냈는지는 알 수 없음: 공격자가 같은 ID로 위조 메시지를 보내는 게 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보안 기능이 없음
    &lt;ul&gt;
      &lt;li&gt;암호화 x&lt;/li&gt;
      &lt;li&gt;인증 x&lt;/li&gt;
      &lt;li&gt;무결성 검증 x&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;network-topology&quot;&gt;Network topology&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;초기: MESH&lt;/strong&gt;&lt;br /&gt;
partially connected&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;복잡한 인터페이스, 정비 어려움, 무게/비용 증가, 확장 어려움&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;현재 : bus&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%201.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단순한 하네스 구조, 정비 쉬움, 비용 감소, 가벼움, 용이한 확장성&lt;/p&gt;

&lt;h2 id=&quot;characteristics&quot;&gt;Characteristics&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Multi-master access / Broadcast&lt;/strong&gt;&lt;/p&gt;
    &lt;p&gt;모든 ECU는 메시지를 송신할 수 있고, 모든 ECU는 그 메시지를 수신할 수 있음&lt;/p&gt;
    
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%202.png&quot; alt=&quot;image.png&quot; /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CSMA/CD (Carrier Sense Multiple Access with Collision Detection)&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 장치가 하나의 공유된 통신 채널을 사용할 때 충돌을 피하기 위한 방법&lt;/li&gt;
      &lt;li&gt;충돌 발생 시 전송을 멈춤&lt;/li&gt;
    &lt;/ul&gt;
    
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%203.png&quot; alt=&quot;image.png&quot; /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Message prioritization&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 노드가 동시에 전송을 시도할 때, 버스 상에서 충돌 없이 우선순위가 높은 메시지만 살아남는 방식&lt;/li&gt;
      &lt;li&gt;Arbitration Field(식별자 + 제어 비트)를 비교&lt;/li&gt;
      &lt;li&gt;Dominant(우성) bit: 0 (&amp;gt;= 0.9 V), Recessive(열성) bit: 1 (&amp;lt;= 0.5 V)&lt;/li&gt;
    &lt;/ul&gt;
    
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%204.png&quot; alt=&quot;image.png&quot; /&gt;

    &lt;p&gt;&lt;strong&gt;2.0A vs 2.0B&lt;/strong&gt;&lt;/p&gt;
    
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%205.png&quot; alt=&quot;image.png&quot; /&gt;
    
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%206.png&quot; alt=&quot;image.png&quot; /&gt;
    
    Arbitration Field와 Control Field가 달라짐

    &lt;table class=&quot;md-table&quot;&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;구분&lt;/th&gt;
          &lt;th&gt;CAN 2.0A&lt;/th&gt;
          &lt;th&gt;CAN 2.0B&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Identifier 길이&lt;/td&gt;
          &lt;td&gt;11비트&lt;/td&gt;
          &lt;td&gt;29비트&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Arbitration Field&lt;/td&gt;
          &lt;td&gt;ID(11) + RTR(1)&lt;/td&gt;
          &lt;td&gt;ID(11) + SRR(1) + IDE(1) + Ext ID(18) + RTR(1)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;IDE 비트&lt;/td&gt;
          &lt;td&gt;0 (Standard)&lt;/td&gt;
          &lt;td&gt;1 (Extended)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;메시지 ID 개수&lt;/td&gt;
          &lt;td&gt;2,048개&lt;/td&gt;
          &lt;td&gt;약 5억 개&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;호환성&lt;/td&gt;
          &lt;td&gt;2.0A끼리만 완전 호환&lt;/td&gt;
          &lt;td&gt;2.0A/2.0B 모두 수신 가능&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;strong&gt;같은 11비트 Base ID를 가진 2.0A 프레임과 2.0B 프레임이 동시에 전송된다면:&lt;/strong&gt;&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;CAN 2.0A Remote Frame&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Arbitration Field = 11비트 ID + RTR(1비트, 0일 수도 있고 1일 수도 있음)&lt;/li&gt;
          &lt;li&gt;Control Field = 1 비트 IDE(항상 0) + 1 bit reservation + 4 bits&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CAN 2.0B Extended Frame&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Arbitration Field = 11비트 Base ID + SRR(항상 1, recessive) + IDE(항상 1, recessive) + 18비트 Extended ID + RTR&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
    &lt;p&gt;→ 2.0A의 RTR이 1이더라도 13번째 비트가 2.0A는 0, 2.0B는 1이므로 A가 우선&lt;/p&gt;
    &lt;br /&gt;
    &lt;p&gt;&lt;strong&gt;문제 예시&lt;/strong&gt;&lt;/p&gt;
    
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%207.png&quot; alt=&quot;image.png&quot; /&gt;

    식별자(ID)가 낮을수록 우선순위가 높음  
    0x123 &amp;lt; 0x140  
    → 0x123가 더 낮은 값이므로 먼저 전송됨  
    참고: 데이터 필드(EF EF EF EF, 00 00 00 00)는 우선순위 결정에 영향 x
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Limited data length (0-8 bytes)&lt;/strong&gt;&lt;/p&gt;
    &lt;p&gt;DLC (Data Length Code) : 데이터 필드에 포함된 데이터 바이트의 수&lt;br /&gt;
    DLC == 데이터 필드 바이트의 길이&lt;/p&gt;
   
   &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%208.png&quot; alt=&quot;image.png&quot; /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Up to 1 Mbit/s data rate&lt;/strong&gt;&lt;/p&gt;
    &lt;p&gt;차량의 실시간 제어와 안정적인 데이터 교환을 가능하게 함&lt;/p&gt;

    | 유형 | 속도 범위 | 설명 |
    | --- | --- | --- |
    | CAN-A | ~10 kbit/s | 저속, 간단한 센서용 |
    | CAN-B | 10~125 kbit/s | 중속, 일반 제어용 |
    | CAN-C | 125~1000 kbit/s | 고속, 실시간 제어용 (최대 1 Mbit/s) |
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;frame&quot;&gt;Frame&lt;/h2&gt;

&lt;h3 id=&quot;data-frame&quot;&gt;Data frame&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%209.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;필드&lt;/th&gt;
      &lt;th&gt;크기&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Start of Frame (SOF)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;1 bit&lt;/td&gt;
      &lt;td&gt;프레임 시작을 알림 (동기화용)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Arbitration Field&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;11비트(2.0A) 또는 29비트(2.0B)&lt;/td&gt;
      &lt;td&gt;메시지 ID와 우선순위 결정, RTR 비트 포함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Control Field&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;6 bits&lt;/td&gt;
      &lt;td&gt;IDE(확장 여부), 예약 비트, DLC(Data Length Code: 데이터 길이)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Data Field&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;0~64 bits (0~8 bytes)&lt;/td&gt;
      &lt;td&gt;실제 전송되는 데이터&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;CRC Field&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;16 bits&lt;/td&gt;
      &lt;td&gt;오류 검출을 위한 Cyclic Redundancy Check&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;ACK Field&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;2 bits&lt;/td&gt;
      &lt;td&gt;수신 노드가 정상 수신 여부를 확인 (송신 노드가 아닌 수신 노드가 설정)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;End of Frame (EOF)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;7 bits&lt;/td&gt;
      &lt;td&gt;프레임 종료 표시&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Interframe Space (IFS)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;3 bits&lt;/td&gt;
      &lt;td&gt;프레임 간 간격 (111)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;각 프레임이 끝난 뒤 3비트(111)의 간격이 들어감&lt;/li&gt;
  &lt;li&gt;RTR(Remote Transmission Request): 0 → remote frame과 구별하기 위함&lt;/li&gt;
  &lt;li&gt;Transmitter node ↔ Receiver node&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;remote-frame&quot;&gt;Remote frame&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2010.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;RTR: 1&lt;br /&gt;
→ remote frame과 data frame이 충돌할 경우 Identifier의 11bit가 동일하다면 data frame의 RTR이 0이기 때문에 항상 우선권을 가짐&lt;/li&gt;
  &lt;li&gt;Transmitter node -&amp;gt; Receiver node (request message)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;error-frame&quot;&gt;Error frame&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2011.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error Flag (6비트)
    &lt;ul&gt;
      &lt;li&gt;오류를 알리는 신호&lt;/li&gt;
      &lt;li&gt;Active Error Flag: 000000&lt;/li&gt;
      &lt;li&gt;Passive Error Flag: 111111&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Echo Error Flag
    &lt;ul&gt;
      &lt;li&gt;Error Flag가 전송된 뒤, 버스 전파 지연(delay) 때문에 다른 ECU들이 뒤늦게 오류를 감지하고 추가로 Error Flag를 내보낼 수 있음&lt;/li&gt;
      &lt;li&gt;이때 기존 Error Flag에 이어 붙는 형태로 나타나는 것이 Echo Error Flag&lt;/li&gt;
      &lt;li&gt;결과적으로 Error Flag + Echo Error Flag로 이어져서, 오류 신호가 네트워크 전체에 확실히 퍼지도록 보장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Error Delimiter (8비트)
    &lt;ul&gt;
      &lt;li&gt;11111111 (recessive)&lt;/li&gt;
      &lt;li&gt;error 프레임의 끝을 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Error frame은 Data/Remote frame뒤에 바로 붙어 전송됨(IFS x)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;에러-종류&quot;&gt;에러 종류&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bit error&lt;/strong&gt;&lt;br /&gt;
    노드가 버스에 보낸 비트와 버스에서 실제로 관측한 비트가 다른 경우 발생&lt;/p&gt;
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2012.png&quot; alt=&quot;image.png&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;여기서 node2가 receiver로 단순히 bus에 올라온 값을 읽음&lt;/li&gt;
      &lt;li&gt;네번째 막대에서 node1 값은 0인데 bus에는 1이 올라감(0이 dominant한데도)&lt;/li&gt;
      &lt;li&gt;node1이 자기 값이랑 bus값을 비교해서 에러 감지, 즉시 active error flag를 내보내며 프레임을 무효화하고 이후에 재전송함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;stuff error&lt;/strong&gt;&lt;br /&gt;
    CAN의 비트 스터핑 규칙(연속 동일 비트 5개 후 반대 비트 삽입, 수신 CAN 노드에서 자동으로 제거됨) 위반 시 발생&lt;/p&gt;
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2013.png&quot; alt=&quot;image.png&quot; /&gt;
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2014.png&quot; alt=&quot;image.png&quot; /&gt;
    &lt;p&gt;붉은색으로 표시된 부분에 스터핑 규칙 적용, error/overload frame에는 적용 x&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CRC error&lt;/strong&gt;&lt;br /&gt;
    수신 노드가 계산한 CRC와 프레임 내 CRC 필드 값이 다름&lt;/p&gt;
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2015.png&quot; alt=&quot;image.png&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Node 1 (송신자)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;데이터 프레임을 전송하면서 마지막에 CRC 시퀀스(X)를 붙여서 보냄&lt;/li&gt;
          &lt;li&gt;이 CRC는 송신자가 자기 데이터(ID, DLC, Data Field 등)를 기반으로 계산한 값&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Bus (공유 매체)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;송신자가 보낸 CRC 값(X)이 그대로 버스에 올라감&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Node 2 (수신자)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Node 2는 수신한 데이터(ID, DLC, Data Field 등)를 기반으로 자체적으로 CRC를 다시 계산&lt;/li&gt;
          &lt;li&gt;계산 결과가 Y였는데, 버스에서 받은 CRC 값(X)와 다르면 → CRC Error&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Form error&lt;/strong&gt;&lt;br /&gt;
    특정 포맷 필드가 표준 규격과 다른 값을 가질 때 발생&lt;/p&gt;
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2016.png&quot; alt=&quot;image.png&quot; /&gt;
    &lt;p&gt;SOF, CRC Del, ACK Del, EOF 의 값이 1이어야 하는데 0으로 관측되는 등&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ACK error&lt;/strong&gt;&lt;br /&gt;
    송신 노드가 ACK 슬롯에서 0을 읽지 못했을 때(응답 노드가 없거나 모두 실패)&lt;/p&gt;
    &lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2017.png&quot; alt=&quot;image.png&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;ACK Slot (1비트)
        &lt;ul&gt;
          &lt;li&gt;송신 노드는 항상 recessive(1)을 내보냄&lt;/li&gt;
          &lt;li&gt;수신 노드가 프레임을 정상적으로 받았다면, 이 자리에서 dominant(0)를 내보냄&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ACK Delimiter (1비트)
        &lt;ul&gt;
          &lt;li&gt;항상 recessive(1)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;송신 노드가 ACK Slot에서 recessive(1)만 읽은 경우 → 즉, 어느 수신 노드도 dominant(0)으로 응답하지 않은 경우 에러&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Appllication error&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;상위 소프트웨어/로직 오류 (의미적 데이터 문제)&lt;/li&gt;
      &lt;li&gt;CAN 프로토콜 레벨에서는 Error Frame이 발생하지 않을 수도 있음&lt;/li&gt;
      &lt;li&gt;대신 ECU가 메시지를 무시하거나 Fault 상태로 전환, DTC 기록 등으로 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;overload-frame&quot;&gt;Overload frame&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2018.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;수신 노드가 내부적으로 바빠서 다음 메시지를 바로 처리할 수 없거나(지연 요구) IFS 구간에서 dominant 비트가 감지되면 Overload Frame으로 인식&lt;/li&gt;
  &lt;li&gt;Overload Flag (6비트)
    &lt;ul&gt;
      &lt;li&gt;000000 (dominant)&lt;/li&gt;
      &lt;li&gt;Error Flag와 동일한 패턴이지만, IFS 구간에서만 나오면 Overload Frame으로 해석&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Overload Delimiter (8비트)
    &lt;ul&gt;
      &lt;li&gt;11111111 (recessive)&lt;/li&gt;
      &lt;li&gt;Overload Frame의 끝을 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;overload frame은 Data/Remote frame뒤에 바로 붙어 전송됨(IFS x)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;attack-scenarios&quot;&gt;Attack Scenarios&lt;/h1&gt;

&lt;h3 id=&quot;dos-denial-of-service-flooding&quot;&gt;DoS (Denial of Service, Flooding)&lt;/h3&gt;

&lt;p&gt;높은 우선순위의 CAN ID  또는 데이터 필드를 주입하면 CAN 버스의 가용성이 파괴됨&lt;/p&gt;

&lt;h3 id=&quot;spoofing&quot;&gt;Spoofing&lt;/h3&gt;

&lt;p&gt;공격자의 의도에 따라 하나 이상의 타겟 ECU를 제어함&lt;br /&gt;
구체적인 데이터 필드로 CAN 메시지를 주입&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2019.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;replay&quot;&gt;Replay&lt;/h3&gt;

&lt;p&gt;정상 주행 중 데이터를 수집해 공격자가 원하는 시점에 이 메시지들을 전송&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2020.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fuzzing&quot;&gt;Fuzzing&lt;/h3&gt;

&lt;p&gt;랜덤한 CAN ID와 데이터 필드를 보냄(공격자도 알 수 x)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2021.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;bus-offsuspension-attack&quot;&gt;Bus-off(Suspension attack)&lt;/h3&gt;

&lt;p&gt;정상적으로 동작하는 ECU를 CAN bus에서 제거하기 위한 공격&lt;br /&gt;
error frame이 발생하면 ECU는 해당 CAN 메시지를 재전송하므로 CAN bus의 부하가 증가함&lt;br /&gt;
→ 이를 해결하기 위해 passive/active/bus-off 모드가 구현되어 있음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error active 모드: 기본 상태, error frames가 128개 미만일 때&lt;/li&gt;
  &lt;li&gt;Error passive 모드: 데이터를 보내기 위해선 IFS (3비트) 이후 8비트를 더 기다림&lt;/li&gt;
  &lt;li&gt;Bus-off: 더 이상 데이터를 전송할 수 없음, ECU 재부팅 후에 데이터 전송 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2025-10-16-can/image%2022.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;masquerade-attackbus-off--spoofingreplay&quot;&gt;Masquerade attack(Bus-off + Spoofing/Replay)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Spoofing 공격에서 정상적으로 작동하는 CAN ID의 데이터도 표시가 됨&lt;/li&gt;
  &lt;li&gt;실제 차량이 정상 데이터와 공격 데이터를 번갈아 수신받기 때문에 공격의 피해가 줄어듦&lt;/li&gt;
  &lt;li&gt;탐지도 쉬워지기 때문에 공격자는 정상적으로 작동하는 ECU를 제거한 뒤 메시지를 보냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실제 차량에 적용된 여러 보호기법을 공부하고 이를 우회해 공격하는 방법을 추가적으로 공부해보고 싶다.&lt;/p&gt;

&lt;p&gt;참고자료: &lt;a href=&quot;https://ocslab.hksecurity.net/publications&quot;&gt;HCRL&lt;/a&gt; 이휘재&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Oct 2025 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C/%EB%B8%94%EB%A1%9C%EA%B7%B8/2025/10/16/can.html</link>
        <guid isPermaLink="true">http://localhost:4000/%EA%B8%B0%EC%88%A0%EB%AC%B8%EC%84%9C/%EB%B8%94%EB%A1%9C%EA%B7%B8/2025/10/16/can.html</guid>
        
        <category>image</category>
        
        
        <category>기술문서/블로그</category>
        
      </item>
    
      <item>
        <title>Knights Frontier</title>
        <description>&lt;h1 id=&quot;활동-정리&quot;&gt;활동 정리&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5 id=&quot;버그바운티&quot;&gt;버그바운티&lt;/h5&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2025-55298&quot;&gt;CVE-2025-55298&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2025-55212&quot;&gt;CVE-2025-55212&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h5 id=&quot;ctf워게임&quot;&gt;CTF/워게임&lt;/h5&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5 id=&quot;개발오픈소스&quot;&gt;개발/오픈소스&lt;/h5&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5 id=&quot;공모전자격증&quot;&gt;공모전/자격증&lt;/h5&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5 id=&quot;논문컨퍼런스&quot;&gt;논문/컨퍼런스&lt;/h5&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5 id=&quot;기술문서블로그&quot;&gt;기술문서/블로그&lt;/h5&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href=&quot;https://gardenia02.tistory.com/&quot;&gt;디지털포렌식 툴&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 15 Oct 2025 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/%EB%A9%94%EC%9D%B8/2025/10/15/first-post.html</link>
        <guid isPermaLink="true">http://localhost:4000/%EB%A9%94%EC%9D%B8/2025/10/15/first-post.html</guid>
        
        <category>image</category>
        
        
        <category>메인</category>
        
      </item>
    
  </channel>
</rss>
